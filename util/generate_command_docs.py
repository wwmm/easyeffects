#!/usr/bin/env python3
import os
import re
import glob
import xml.etree.ElementTree as ET

TAGS_FILE = "src/tags_plugin_name.hpp"
KCFG_DIR = "src/contents/kcfg"
OUTPUT_FILE = "src/contents/help/plugin-properties.html"

def get_tags():
    ids = []
    if not os.path.exists(TAGS_FILE):
        print(f"Error: {TAGS_FILE} not found.")
        return ids

    regex = re.compile(r'CREATE_PROPERTY\s*\(\s*QString\s*,\s*\w+\s*,\s*QStringLiteral\s*\(\s*"([^"]+)"\s*\)\s*\)')

    with open(TAGS_FILE, 'r') as f:
        for line in f:
            match = regex.search(line)
            if match:
                ids.append(match.group(1))
    return sorted(ids)

def main():
    if not os.path.exists(KCFG_DIR):
        print(f"Error: Directory '{KCFG_DIR}' not found. Run this from the repo source root.")
        exit(1)

    tags = get_tags()

    html = [
        "<!DOCTYPE html>",
        "<!--",
        "  AUTOGENERATED FILE - DO NOT MODIFY MANUALLY.",
        "  This file is generated by: util/generate_command_docs.py",
        "-->",
        "<html><head>",
        '<meta charset="UTF-8">',
        '<title>Plugin Properties</title>',
        '<link rel="stylesheet" type="text/css" href="C.css">',
        "<style>",
        "  table { width: 100%; border-collapse: collapse; margin-top: 1em; }",
        "  th, td { text-align: left; padding: 8px; border-bottom: 1px solid #ddd; }",
        "  th { background-color: #f2f2f2; }",
        "  .mono { font-family: monospace; }",
        "</style>",
        "</head><body>",
        '<main><div class="page"><article><div class="region"><div class="contents pagewide">',
        '<h1 class="title">Controllable plugin properties</h1>',
        '<p>The following properties can be modified via the local socket server using:</p>',
        '<pre class="code">set_property:&lt;pipeline&gt;:&lt;plugin_name&gt;:&lt;instance_id&gt;:&lt;property&gt;:&lt;value&gt;</pre>',
        '<table><thead><tr><th>Plugin ID</th><th>Property</th><th>Type</th><th>Default</th></tr></thead><tbody>'
    ]

    for tag in tags:
        kcfg_path = os.path.join(KCFG_DIR, f"easyeffects_db_{tag}.kcfg")

        if not os.path.exists(kcfg_path):
            continue

        try:
            tree = ET.parse(kcfg_path)
            root = tree.getroot()
            ns = {"kcfg": "http://www.kde.org/standards/kcfg/1.0"}
            found_plugins = []

            for group in root.findall("kcfg:group", ns):
                for entry in group.findall("kcfg:entry", ns):
                    prop_name = entry.get('name')
                    prop_type = entry.get('type')

                    default_node = entry.find("kcfg:default", ns)
                    if default_node is not None:
                        default_val = default_node.text
                        if default_node.get("code") == "true":
                            default_val = "<em>calculated</em>"
                    else:
                        default_val = "-"

                    choices_html = ""
                    if prop_type == "Enum":
                        choices = entry.find("kcfg:choices", ns)
                        if choices is not None:
                            names = [c.get("name") for c in choices.findall("kcfg:choice", ns)]
                            choices_html = f" <br><small>({', '.join(names)})</small>"

                    html.append(
                        f"<tr>"
                        f"<td class='mono'><b>{tag}</b></td>"
                        f"<td class='mono'>{prop_name}</td>"
                        f"<td>{prop_type}{choices_html}</td>"
                        f"<td class='mono'>{default_val}</td>"
                        f"</tr>"
                    )
                    found_plugins.append(tag)
        except Exception as e:
            print(f"Error parsing {kcfg_path}: {e}")

    html.extend([
        "</tbody></table>",
        "</div></div></article></div></main>",
        "</body></html>"
    ])

    with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
        f.write("\n".join(html))

    print(f"Documentation generated at: {OUTPUT_FILE} for {len(found_plugins)} plugins.")

if __name__ == "__main__":
    main()
